# **üîπ Spring Cache ‚Äì In-Depth Guide**

## **üìå What is Spring Cache?**
Spring Cache **optimizes performance** by reducing redundant database queries and computation by storing frequently accessed data in memory.

‚úÖ **Use Cases**
- **Reduce DB calls** for frequently accessed data
- **Improve performance** by caching results
- **Avoid redundant calculations**
- **Store API responses temporarily**

---

# **üîπ Step-by-Step Implementation of Spring Cache in Java**

## **üìå Step 1: Add Dependencies**
Include the necessary dependencies in `pom.xml`.

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!-- Use Caffeine for in-memory caching -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>3.1.2</version>
</dependency>
```
‚úÖ **`spring-boot-starter-cache`** enables Spring Cache  
‚úÖ **Caffeine** is used for high-performance in-memory caching

---

## **üìå Step 2: Enable Caching in Spring Boot**
Annotate the main application class with `@EnableCaching`.

```java
package com.example.cache;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching  // Enables Spring Cache
public class CacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(CacheApplication.class, args);
    }
}
```
‚úÖ **Activates caching in the application**

---

## **üìå Step 3: Implement Caching in a Service Layer**
Use `@Cacheable`, `@CachePut`, and `@CacheEvict` annotations.

```java
package com.example.cache.service;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public String getProductById(Long id) {
        System.out.println("Fetching product from database...");
        return "Product-" + id;
    }
}
```
‚úÖ **`@Cacheable` caches method results**  
‚úÖ **If the data is cached, it skips database access**

---

## **üìå Step 4: Define Custom Cache Configuration**
You can configure caching with **Caffeine**.

```java
package com.example.cache.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("products");
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(10, TimeUnit.MINUTES)  // Cache expires in 10 min
                .maximumSize(100)  // Store max 100 items
        );
        return cacheManager;
    }
}
```
‚úÖ **Customizes cache expiration and size**

---

## **üìå Step 5: Evict Cache When Data Changes**
When data is updated, we must clear outdated cache entries.

```java
package com.example.cache.service;

import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.stereotype.Service;

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public String getProductById(Long id) {
        System.out.println("Fetching product from database...");
        return "Product-" + id;
    }

    @CachePut(value = "products", key = "#id")
    public String updateProduct(Long id, String productName) {
        System.out.println("Updating product...");
        return productName;
    }

    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        System.out.println("Deleting product from cache...");
    }
}
```
‚úÖ **`@CachePut` updates cache when data is updated**  
‚úÖ **`@CacheEvict` removes outdated cache data**

---

## **üìå Step 6: Test Caching**
Test the caching behavior using a simple `@RestController`.

```java
package com.example.cache.controller;

import com.example.cache.service.ProductService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping("/{id}")
    public String getProduct(@PathVariable Long id) {
        return productService.getProductById(id);
    }

    @PutMapping("/{id}")
    public String updateProduct(@PathVariable Long id, @RequestBody String name) {
        return productService.updateProduct(id, name);
    }

    @DeleteMapping("/{id}")
    public void deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
    }
}
```
‚úÖ **`GET /products/{id}` ‚Äì Fetches from cache after first request**  
‚úÖ **`PUT /products/{id}` ‚Äì Updates cache**  
‚úÖ **`DELETE /products/{id}` ‚Äì Clears cache**

---

# **üîπ Advanced Spring Cache Features**
| Feature  | Description |
|----------|------------|
| **Custom Cache Manager** | Define expiration, eviction policies. |
| **Multi-Level Caching** | Combine **in-memory + Redis** caching. |
| **Conditional Caching** | Use `condition` in `@Cacheable` to cache only when needed. |
| **Distributed Cache** | Use **Redis** or **Hazelcast** for distributed caching. |

---

# **‚úÖ Summary**
üöÄ **Spring Cache boosts performance by reducing redundant DB queries**  
‚ö° **`@Cacheable`, `@CachePut`, `@CacheEvict` manage caching efficiently**  
üîπ **Supports in-memory (Caffeine) and distributed caching (Redis, Hazelcast)**  
üåç **Highly configurable for custom cache policies**

Let me know if you need more details! üöÄ

# **üîπ Multi-Level Caching: In-Memory + Redis Caching**

## **üìå What is Multi-Level Caching?**
Multi-level caching **combines different caching layers** to optimize performance.
- **Level 1 (L1)** ‚Äì **In-Memory Cache (Caffeine, EhCache, Guava, etc.)** (Fastest)
- **Level 2 (L2)** ‚Äì **Distributed Cache (Redis, Hazelcast, Memcached, etc.)**

This ensures:  
‚úÖ **Faster access** for frequently used data (**L1 memory cache first**)  
‚úÖ **Consistency** using a shared **L2 distributed cache**  
‚úÖ **Reduced DB hits**, even across multiple services

---

## **üîπ Step-by-Step Multi-Level Caching (Caffeine + Redis)**

### **üìå Step 1: Add Dependencies**
Include **Caffeine (L1) & Redis (L2)** in `pom.xml`.

```xml
<!-- Spring Boot Cache -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!-- Caffeine for L1 Cache -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>3.1.2</version>
</dependency>

<!-- Redis for L2 Cache -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```
‚úÖ **Caffeine (L1)** stores data in local memory.  
‚úÖ **Redis (L2)** stores cache at the distributed level.

---

### **üìå Step 2: Configure Multi-Level Caching**
Define a **custom `CacheManager`** to use both L1 (Caffeine) & L2 (Redis).

```java
package com.example.cache.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.cache.support.CompositeCacheManager;
import org.springframework.cache.support.SimpleCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;

import java.time.Duration;
import java.util.Arrays;
import java.util.Collections;

@Configuration
@EnableCaching
public class MultiLevelCacheConfig {

    // L1 - In-Memory Cache (Caffeine)
    @Bean
    public CaffeineCacheManager caffeineCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("products");
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(Duration.ofMinutes(5))  // In-memory expires after 5 min
                .maximumSize(100)  // Store max 100 items
        );
        return cacheManager;
    }

    // L2 - Redis Cache
    @Bean
    public RedisCacheManager redisCacheManager(LettuceConnectionFactory redisConnectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1))  // Redis cache expires in 1 hour
                .disableCachingNullValues();
        return RedisCacheManager.builder(redisConnectionFactory)
                .cacheDefaults(config)
                .build();
    }

    // Composite Cache Manager (L1 + L2)
    @Bean
    public CacheManager multiLevelCacheManager(CaffeineCacheManager caffeineCacheManager, RedisCacheManager redisCacheManager) {
        CompositeCacheManager compositeCacheManager = new CompositeCacheManager(
                caffeineCacheManager,  // L1 - Fastest
                redisCacheManager  // L2 - Persistent
        );
        compositeCacheManager.setFallbackToNoOpCache(true);
        return compositeCacheManager;
    }
}
```
‚úÖ **L1 (Caffeine)** ‚Äì Fastest, in-memory cache with 5 min expiry.  
‚úÖ **L2 (Redis)** ‚Äì Shared cache with 1-hour expiry.  
‚úÖ **CompositeCacheManager** ensures L1 is used first, then L2.

---

### **üìå Step 3: Use Multi-Level Cache in Service**
Modify the service to use caching.

```java
package com.example.cache.service;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id", sync = true)
    public String getProductById(Long id) {
        System.out.println("Fetching from DB...");
        return "Product-" + id;
    }
}
```
‚úÖ **Checks L1 (Caffeine) first**  
‚úÖ **If not found, checks L2 (Redis)**  
‚úÖ **If not in L2, fetches from DB and caches it**

---

### **üìå Step 4: Test the Multi-Level Cache**
Call the endpoint twice and observe the logs.

```java
package com.example.cache.controller;

import com.example.cache.service.ProductService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping("/{id}")
    public String getProduct(@PathVariable Long id) {
        return productService.getProductById(id);
    }
}
```

### **‚úÖ Test Calls**
```sh
# First Request (DB Call)
curl http://localhost:8080/products/1
# Output: Fetching from DB...

# Second Request (Cache Hit - L1)
curl http://localhost:8080/products/1
# Output: (No DB Call, served from Caffeine)

# After 5 minutes (Cache Hit - L2)
curl http://localhost:8080/products/1
# Output: (Served from Redis)
```
‚úÖ **First call fetches from DB**  
‚úÖ **Second call serves from L1 cache (Caffeine) ‚Äì Fastest**  
‚úÖ **After 5 minutes, L1 expires, fetches from L2 (Redis)**

---

# **üîπ Multi-Level Caching Workflow**
### **1Ô∏è‚É£ Request Flow**
1. **Check L1 (Caffeine) Cache**
    - ‚úÖ If **found** ‚Üí return immediately (fastest access)
    - ‚ùå If **not found** ‚Üí check L2

2. **Check L2 (Redis) Cache**
    - ‚úÖ If **found** ‚Üí store in L1 for faster access next time
    - ‚ùå If **not found** ‚Üí fetch from DB

3. **Fetch from Database**
    - Store result in **L1 (Caffeine)** for **5 min**
    - Store result in **L2 (Redis)** for **1 hour**

---

# **üîπ Why Use Multi-Level Caching?**
| Feature  | L1 (Caffeine) | L2 (Redis) |
|----------|-------------|-----------|
| **Speed** | Ultra-fast (in-memory) | Fast (network-based) |
| **Persistence** | Lost on restart | Persistent across services |
| **Scalability** | Local only | Shared across instances |
| **Eviction** | Short-term cache | Long-term storage |

‚úÖ **Fast access** from **L1 (Caffeine)**  
‚úÖ **Consistent data** across services via **L2 (Redis)**  
‚úÖ **Reduced DB load** with caching at **multiple levels**

---

# **‚úÖ Summary**
üöÄ **Multi-Level Caching combines in-memory (L1) and distributed (L2) caches**  
üîπ **L1 (Caffeine) is fastest, L2 (Redis) ensures persistence**  
‚ö° **Optimized DB queries ‚Üí Faster response times**  
üåç **Scales efficiently in Microservices & Kubernetes**

Let me know if you need more details! üöÄ
